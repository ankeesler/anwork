// Code generated by counterfeiter. DO NOT EDIT.
package task2fakes

import (
	sync "sync"

	task2 "github.com/ankeesler/anwork/task2"
)

type FakeRepo struct {
	CreateEventStub        func(*task2.Event) error
	createEventMutex       sync.RWMutex
	createEventArgsForCall []struct {
		arg1 *task2.Event
	}
	createEventReturns struct {
		result1 error
	}
	createEventReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTaskStub        func(*task2.Task) error
	createTaskMutex       sync.RWMutex
	createTaskArgsForCall []struct {
		arg1 *task2.Task
	}
	createTaskReturns struct {
		result1 error
	}
	createTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEventStub        func(*task2.Event) error
	deleteEventMutex       sync.RWMutex
	deleteEventArgsForCall []struct {
		arg1 *task2.Event
	}
	deleteEventReturns struct {
		result1 error
	}
	deleteEventReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(*task2.Task) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 *task2.Task
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	EventsStub        func() ([]*task2.Event, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
	}
	eventsReturns struct {
		result1 []*task2.Event
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 []*task2.Event
		result2 error
	}
	FindEventByIDStub        func(int) (*task2.Event, error)
	findEventByIDMutex       sync.RWMutex
	findEventByIDArgsForCall []struct {
		arg1 int
	}
	findEventByIDReturns struct {
		result1 *task2.Event
		result2 error
	}
	findEventByIDReturnsOnCall map[int]struct {
		result1 *task2.Event
		result2 error
	}
	FindTaskByIDStub        func(int) (*task2.Task, error)
	findTaskByIDMutex       sync.RWMutex
	findTaskByIDArgsForCall []struct {
		arg1 int
	}
	findTaskByIDReturns struct {
		result1 *task2.Task
		result2 error
	}
	findTaskByIDReturnsOnCall map[int]struct {
		result1 *task2.Task
		result2 error
	}
	FindTaskByNameStub        func(string) (*task2.Task, error)
	findTaskByNameMutex       sync.RWMutex
	findTaskByNameArgsForCall []struct {
		arg1 string
	}
	findTaskByNameReturns struct {
		result1 *task2.Task
		result2 error
	}
	findTaskByNameReturnsOnCall map[int]struct {
		result1 *task2.Task
		result2 error
	}
	TasksStub        func() ([]*task2.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
	}
	tasksReturns struct {
		result1 []*task2.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*task2.Task
		result2 error
	}
	UpdateTaskStub        func(*task2.Task) error
	updateTaskMutex       sync.RWMutex
	updateTaskArgsForCall []struct {
		arg1 *task2.Task
	}
	updateTaskReturns struct {
		result1 error
	}
	updateTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepo) CreateEvent(arg1 *task2.Event) error {
	fake.createEventMutex.Lock()
	ret, specificReturn := fake.createEventReturnsOnCall[len(fake.createEventArgsForCall)]
	fake.createEventArgsForCall = append(fake.createEventArgsForCall, struct {
		arg1 *task2.Event
	}{arg1})
	fake.recordInvocation("CreateEvent", []interface{}{arg1})
	fake.createEventMutex.Unlock()
	if fake.CreateEventStub != nil {
		return fake.CreateEventStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createEventReturns
	return fakeReturns.result1
}

func (fake *FakeRepo) CreateEventCallCount() int {
	fake.createEventMutex.RLock()
	defer fake.createEventMutex.RUnlock()
	return len(fake.createEventArgsForCall)
}

func (fake *FakeRepo) CreateEventCalls(stub func(*task2.Event) error) {
	fake.createEventMutex.Lock()
	defer fake.createEventMutex.Unlock()
	fake.CreateEventStub = stub
}

func (fake *FakeRepo) CreateEventArgsForCall(i int) *task2.Event {
	fake.createEventMutex.RLock()
	defer fake.createEventMutex.RUnlock()
	argsForCall := fake.createEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) CreateEventReturns(result1 error) {
	fake.createEventMutex.Lock()
	defer fake.createEventMutex.Unlock()
	fake.CreateEventStub = nil
	fake.createEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) CreateEventReturnsOnCall(i int, result1 error) {
	fake.createEventMutex.Lock()
	defer fake.createEventMutex.Unlock()
	fake.CreateEventStub = nil
	if fake.createEventReturnsOnCall == nil {
		fake.createEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) CreateTask(arg1 *task2.Task) error {
	fake.createTaskMutex.Lock()
	ret, specificReturn := fake.createTaskReturnsOnCall[len(fake.createTaskArgsForCall)]
	fake.createTaskArgsForCall = append(fake.createTaskArgsForCall, struct {
		arg1 *task2.Task
	}{arg1})
	fake.recordInvocation("CreateTask", []interface{}{arg1})
	fake.createTaskMutex.Unlock()
	if fake.CreateTaskStub != nil {
		return fake.CreateTaskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createTaskReturns
	return fakeReturns.result1
}

func (fake *FakeRepo) CreateTaskCallCount() int {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	return len(fake.createTaskArgsForCall)
}

func (fake *FakeRepo) CreateTaskCalls(stub func(*task2.Task) error) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = stub
}

func (fake *FakeRepo) CreateTaskArgsForCall(i int) *task2.Task {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	argsForCall := fake.createTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) CreateTaskReturns(result1 error) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = nil
	fake.createTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) CreateTaskReturnsOnCall(i int, result1 error) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = nil
	if fake.createTaskReturnsOnCall == nil {
		fake.createTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) DeleteEvent(arg1 *task2.Event) error {
	fake.deleteEventMutex.Lock()
	ret, specificReturn := fake.deleteEventReturnsOnCall[len(fake.deleteEventArgsForCall)]
	fake.deleteEventArgsForCall = append(fake.deleteEventArgsForCall, struct {
		arg1 *task2.Event
	}{arg1})
	fake.recordInvocation("DeleteEvent", []interface{}{arg1})
	fake.deleteEventMutex.Unlock()
	if fake.DeleteEventStub != nil {
		return fake.DeleteEventStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteEventReturns
	return fakeReturns.result1
}

func (fake *FakeRepo) DeleteEventCallCount() int {
	fake.deleteEventMutex.RLock()
	defer fake.deleteEventMutex.RUnlock()
	return len(fake.deleteEventArgsForCall)
}

func (fake *FakeRepo) DeleteEventCalls(stub func(*task2.Event) error) {
	fake.deleteEventMutex.Lock()
	defer fake.deleteEventMutex.Unlock()
	fake.DeleteEventStub = stub
}

func (fake *FakeRepo) DeleteEventArgsForCall(i int) *task2.Event {
	fake.deleteEventMutex.RLock()
	defer fake.deleteEventMutex.RUnlock()
	argsForCall := fake.deleteEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) DeleteEventReturns(result1 error) {
	fake.deleteEventMutex.Lock()
	defer fake.deleteEventMutex.Unlock()
	fake.DeleteEventStub = nil
	fake.deleteEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) DeleteEventReturnsOnCall(i int, result1 error) {
	fake.deleteEventMutex.Lock()
	defer fake.deleteEventMutex.Unlock()
	fake.DeleteEventStub = nil
	if fake.deleteEventReturnsOnCall == nil {
		fake.deleteEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) DeleteTask(arg1 *task2.Task) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 *task2.Task
	}{arg1})
	fake.recordInvocation("DeleteTask", []interface{}{arg1})
	fake.deleteTaskMutex.Unlock()
	if fake.DeleteTaskStub != nil {
		return fake.DeleteTaskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteTaskReturns
	return fakeReturns.result1
}

func (fake *FakeRepo) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeRepo) DeleteTaskCalls(stub func(*task2.Task) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeRepo) DeleteTaskArgsForCall(i int) *task2.Task {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) Events() ([]*task2.Event, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
	}{})
	fake.recordInvocation("Events", []interface{}{})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.eventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepo) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeRepo) EventsCalls(stub func() ([]*task2.Event, error)) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeRepo) EventsReturns(result1 []*task2.Event, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 []*task2.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) EventsReturnsOnCall(i int, result1 []*task2.Event, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 []*task2.Event
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 []*task2.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) FindEventByID(arg1 int) (*task2.Event, error) {
	fake.findEventByIDMutex.Lock()
	ret, specificReturn := fake.findEventByIDReturnsOnCall[len(fake.findEventByIDArgsForCall)]
	fake.findEventByIDArgsForCall = append(fake.findEventByIDArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindEventByID", []interface{}{arg1})
	fake.findEventByIDMutex.Unlock()
	if fake.FindEventByIDStub != nil {
		return fake.FindEventByIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findEventByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepo) FindEventByIDCallCount() int {
	fake.findEventByIDMutex.RLock()
	defer fake.findEventByIDMutex.RUnlock()
	return len(fake.findEventByIDArgsForCall)
}

func (fake *FakeRepo) FindEventByIDCalls(stub func(int) (*task2.Event, error)) {
	fake.findEventByIDMutex.Lock()
	defer fake.findEventByIDMutex.Unlock()
	fake.FindEventByIDStub = stub
}

func (fake *FakeRepo) FindEventByIDArgsForCall(i int) int {
	fake.findEventByIDMutex.RLock()
	defer fake.findEventByIDMutex.RUnlock()
	argsForCall := fake.findEventByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) FindEventByIDReturns(result1 *task2.Event, result2 error) {
	fake.findEventByIDMutex.Lock()
	defer fake.findEventByIDMutex.Unlock()
	fake.FindEventByIDStub = nil
	fake.findEventByIDReturns = struct {
		result1 *task2.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) FindEventByIDReturnsOnCall(i int, result1 *task2.Event, result2 error) {
	fake.findEventByIDMutex.Lock()
	defer fake.findEventByIDMutex.Unlock()
	fake.FindEventByIDStub = nil
	if fake.findEventByIDReturnsOnCall == nil {
		fake.findEventByIDReturnsOnCall = make(map[int]struct {
			result1 *task2.Event
			result2 error
		})
	}
	fake.findEventByIDReturnsOnCall[i] = struct {
		result1 *task2.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) FindTaskByID(arg1 int) (*task2.Task, error) {
	fake.findTaskByIDMutex.Lock()
	ret, specificReturn := fake.findTaskByIDReturnsOnCall[len(fake.findTaskByIDArgsForCall)]
	fake.findTaskByIDArgsForCall = append(fake.findTaskByIDArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindTaskByID", []interface{}{arg1})
	fake.findTaskByIDMutex.Unlock()
	if fake.FindTaskByIDStub != nil {
		return fake.FindTaskByIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findTaskByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepo) FindTaskByIDCallCount() int {
	fake.findTaskByIDMutex.RLock()
	defer fake.findTaskByIDMutex.RUnlock()
	return len(fake.findTaskByIDArgsForCall)
}

func (fake *FakeRepo) FindTaskByIDCalls(stub func(int) (*task2.Task, error)) {
	fake.findTaskByIDMutex.Lock()
	defer fake.findTaskByIDMutex.Unlock()
	fake.FindTaskByIDStub = stub
}

func (fake *FakeRepo) FindTaskByIDArgsForCall(i int) int {
	fake.findTaskByIDMutex.RLock()
	defer fake.findTaskByIDMutex.RUnlock()
	argsForCall := fake.findTaskByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) FindTaskByIDReturns(result1 *task2.Task, result2 error) {
	fake.findTaskByIDMutex.Lock()
	defer fake.findTaskByIDMutex.Unlock()
	fake.FindTaskByIDStub = nil
	fake.findTaskByIDReturns = struct {
		result1 *task2.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) FindTaskByIDReturnsOnCall(i int, result1 *task2.Task, result2 error) {
	fake.findTaskByIDMutex.Lock()
	defer fake.findTaskByIDMutex.Unlock()
	fake.FindTaskByIDStub = nil
	if fake.findTaskByIDReturnsOnCall == nil {
		fake.findTaskByIDReturnsOnCall = make(map[int]struct {
			result1 *task2.Task
			result2 error
		})
	}
	fake.findTaskByIDReturnsOnCall[i] = struct {
		result1 *task2.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) FindTaskByName(arg1 string) (*task2.Task, error) {
	fake.findTaskByNameMutex.Lock()
	ret, specificReturn := fake.findTaskByNameReturnsOnCall[len(fake.findTaskByNameArgsForCall)]
	fake.findTaskByNameArgsForCall = append(fake.findTaskByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindTaskByName", []interface{}{arg1})
	fake.findTaskByNameMutex.Unlock()
	if fake.FindTaskByNameStub != nil {
		return fake.FindTaskByNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findTaskByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepo) FindTaskByNameCallCount() int {
	fake.findTaskByNameMutex.RLock()
	defer fake.findTaskByNameMutex.RUnlock()
	return len(fake.findTaskByNameArgsForCall)
}

func (fake *FakeRepo) FindTaskByNameCalls(stub func(string) (*task2.Task, error)) {
	fake.findTaskByNameMutex.Lock()
	defer fake.findTaskByNameMutex.Unlock()
	fake.FindTaskByNameStub = stub
}

func (fake *FakeRepo) FindTaskByNameArgsForCall(i int) string {
	fake.findTaskByNameMutex.RLock()
	defer fake.findTaskByNameMutex.RUnlock()
	argsForCall := fake.findTaskByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) FindTaskByNameReturns(result1 *task2.Task, result2 error) {
	fake.findTaskByNameMutex.Lock()
	defer fake.findTaskByNameMutex.Unlock()
	fake.FindTaskByNameStub = nil
	fake.findTaskByNameReturns = struct {
		result1 *task2.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) FindTaskByNameReturnsOnCall(i int, result1 *task2.Task, result2 error) {
	fake.findTaskByNameMutex.Lock()
	defer fake.findTaskByNameMutex.Unlock()
	fake.FindTaskByNameStub = nil
	if fake.findTaskByNameReturnsOnCall == nil {
		fake.findTaskByNameReturnsOnCall = make(map[int]struct {
			result1 *task2.Task
			result2 error
		})
	}
	fake.findTaskByNameReturnsOnCall[i] = struct {
		result1 *task2.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) Tasks() ([]*task2.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
	}{})
	fake.recordInvocation("Tasks", []interface{}{})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepo) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeRepo) TasksCalls(stub func() ([]*task2.Task, error)) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = stub
}

func (fake *FakeRepo) TasksReturns(result1 []*task2.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*task2.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) TasksReturnsOnCall(i int, result1 []*task2.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*task2.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*task2.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeRepo) UpdateTask(arg1 *task2.Task) error {
	fake.updateTaskMutex.Lock()
	ret, specificReturn := fake.updateTaskReturnsOnCall[len(fake.updateTaskArgsForCall)]
	fake.updateTaskArgsForCall = append(fake.updateTaskArgsForCall, struct {
		arg1 *task2.Task
	}{arg1})
	fake.recordInvocation("UpdateTask", []interface{}{arg1})
	fake.updateTaskMutex.Unlock()
	if fake.UpdateTaskStub != nil {
		return fake.UpdateTaskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateTaskReturns
	return fakeReturns.result1
}

func (fake *FakeRepo) UpdateTaskCallCount() int {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	return len(fake.updateTaskArgsForCall)
}

func (fake *FakeRepo) UpdateTaskCalls(stub func(*task2.Task) error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = stub
}

func (fake *FakeRepo) UpdateTaskArgsForCall(i int) *task2.Task {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	argsForCall := fake.updateTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepo) UpdateTaskReturns(result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	fake.updateTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) UpdateTaskReturnsOnCall(i int, result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	if fake.updateTaskReturnsOnCall == nil {
		fake.updateTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepo) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createEventMutex.RLock()
	defer fake.createEventMutex.RUnlock()
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	fake.deleteEventMutex.RLock()
	defer fake.deleteEventMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.findEventByIDMutex.RLock()
	defer fake.findEventByIDMutex.RUnlock()
	fake.findTaskByIDMutex.RLock()
	defer fake.findTaskByIDMutex.RUnlock()
	fake.findTaskByNameMutex.RLock()
	defer fake.findTaskByNameMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepo) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ task2.Repo = new(FakeRepo)
